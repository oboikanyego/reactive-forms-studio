import { Injectable, EventEmitter, Directive, Input, Output, HostListener, Component, Renderer2, ViewChild, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { HttpHeaders, HttpClient, HttpClientModule } from '@angular/common/http';
import { FormsModule } from '@angular/forms';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { FlexLayoutModule } from '@angular/flex-layout';
import { NSystemService, NeutrinosSeedServicesModule } from 'neutrinos-seed-services';
import { MatIconModule } from '@angular/material/icon';
import { MatDialogRef, MatDialog, MatDialogModule } from '@angular/material/dialog';
import { MatButtonModule } from '@angular/material/button';
import { MatButtonToggleModule } from '@angular/material/button-toggle';
import signing from 'signature_pad';

class NFileIOService {
    constructor(http) {
        this.http = http;
        this.checkFileExist = (path, fileName, i, callback) => {
            return window.resolveLocalFileSystemURL(path + fileName, () => {
                let length = 4;
                if (fileName.lastIndexOf('(') > -1) {
                    const isExist = parseInt(fileName.slice((fileName.lastIndexOf('(') + 1), fileName.lastIndexOf(')')), 10);
                    if (!isNaN(isExist)) {
                        i = isExist + 1;
                        if (i > 10 && i < 100) {
                            length += 1;
                        }
                        else if (i > 100) {
                            length += 2;
                        }
                        fileName = fileName.slice(0, (fileName.lastIndexOf('.') - length)) + ' (' + i + ')' + fileName.slice(fileName.lastIndexOf('.'));
                    }
                    else {
                        i += 1;
                        fileName = fileName.slice(0, (fileName.lastIndexOf('.'))) + fileName.slice(fileName.lastIndexOf('.'));
                        fileName = fileName.slice(0, (fileName.lastIndexOf('.'))) + ' (' + i + ')' + fileName.slice(fileName.lastIndexOf('.'));
                    }
                }
                else {
                    i += 1;
                    fileName = fileName.slice(0, (fileName.lastIndexOf('.'))) + fileName.slice(fileName.lastIndexOf('.'));
                    fileName = fileName.slice(0, (fileName.lastIndexOf('.'))) + ' (' + i + ')' + fileName.slice(fileName.lastIndexOf('.'));
                }
                return this.checkFileExist(path, fileName, i, callback);
            }, () => {
                return callback(fileName);
            });
        };
        this.systemService = NSystemService.getInstance();
        this.appProperties = this.systemService.getVal('properties');
    }
    getFileInfo(options) {
        let dataModelURL = this.systemService.getDataModelUrl();
        if (options.metadata) {
            dataModelURL += `${this.appProperties.appName}_${options.entityName}.files?filter={"metadata.key": "${options.metadata.key}"}`;
        }
        else {
            dataModelURL += `${this.appProperties.appName}_${options.entityName}.files/${options.fileId}`;
        }
        return this.http.get(dataModelURL);
    }
    getFormData(fileUri) {
        return new Promise((resolve, reject) => {
            window.resolveLocalFileSystemURL(fileUri, (fileEntry) => {
                fileEntry.file((file) => {
                    const reader = new FileReader();
                    reader.onerror = evt => {
                        return reject(evt);
                    };
                    reader.onloadend = evt => {
                        const formData = new FormData();
                        const blob = new Blob([new Uint8Array(reader.result)], { type: file.type });
                        formData.append('file', blob, file.name);
                        return resolve(formData);
                    };
                    reader.readAsArrayBuffer(file);
                });
            }, (error) => {
                return reject(error);
            });
        });
    }
    getPicture(cameraOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                navigator.camera.getPicture((imageUri) => {
                    this.getFormData(imageUri).then(res => {
                        return resolve(res);
                    }).catch(err => reject(err));
                }, (error) => {
                    return reject(error);
                }, cameraOptions);
            }, false);
        });
    }
    scanPicture(scanOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                if (scanOptions.hasOwnProperty('sourceType') && scanOptions.hasOwnProperty('doUpload')) {
                    scan.scanDoc(scanOptions.sourceType, (imageUri) => {
                        if (scanOptions.doUpload) {
                            this.getFormData(imageUri).then(res => {
                                return resolve(res);
                            }).catch(err => reject(err));
                        }
                        else {
                            resolve(imageUri);
                        }
                    }, (error) => {
                        return reject(error);
                    });
                }
                else {
                    reject('sourceType not found');
                }
            }, false);
        });
    }
    //Barcode
    getBarcode(barcodeOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                cordova.plugins.barcodeScanner.scan((result) => {
                    if (result.cancelled) {
                        return reject(result);
                    }
                    else {
                        return resolve(result);
                    }
                }, (error) => {
                    return reject(error);
                }, barcodeOptions);
            }, false);
        });
    }
    //Video
    getVideo(videoOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                navigator.device.capture.captureVideo((mediaFiles) => {
                    var imageUri = mediaFiles[0].fullPath;
                    this.getFormData(imageUri).then(res => {
                        return resolve(res);
                    }).catch(err => reject(err));
                }, (error) => {
                    return reject(error);
                }, {});
            }, false);
        });
    }
    //tts
    getTts(ttsOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                if (ttsOptions.hasOwnProperty('text')) {
                    TTS.speak(ttsOptions).then(() => {
                        return resolve('success');
                    }, (reason) => {
                        return reject(reason);
                    });
                }
                else {
                    reject('text not found');
                }
            }, false);
        });
    }
    //shake
    getShake(shakeOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                if (shakeOptions.hasOwnProperty('start') && shakeOptions.hasOwnProperty('sensitivity')) {
                    if (shakeOptions.start) {
                        shake.startWatch(() => {
                            return resolve('success');
                        }, shakeOptions.sensitivity, () => {
                            return reject('error');
                        });
                    }
                    else {
                        shake.stopWatch();
                    }
                }
                else {
                    reject('start or sensitivity not found');
                }
            }, false);
        });
    }
    //ocr
    getOcr(ocrOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                if (ocrOptions.hasOwnProperty('uriOrBase') && ocrOptions.hasOwnProperty('returnType')) {
                    navigator.camera.getPicture((imageData) => {
                        textocr.recText(ocrOptions.uriOrBase, ocrOptions.returnType, imageData, (recognizedText) => {
                            return resolve(recognizedText);
                        }, (message) => {
                            return reject(message);
                        });
                    }, (message) => {
                        return reject(message);
                    }, ocrOptions);
                }
                else {
                    reject('uriOrBase or returnType not found');
                }
            }, false);
        });
    }
    //fingerprint
    getFingerprint(fingerprintOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                if (fingerprintOptions.hasOwnProperty('clientId') && fingerprintOptions.hasOwnProperty('clientSecret')) {
                    Fingerprint.isAvailable((result) => {
                        Fingerprint.show(fingerprintOptions, () => {
                            return resolve('success');
                        }, (err) => {
                            return reject(err);
                        });
                    }, (message) => {
                        return reject(message);
                    });
                }
                else {
                    reject('clientId or clientSecret not found');
                }
            }, false);
        });
    }
    upload(options) {
        return new Promise((resolve, reject) => {
            let body = new FormData();
            if (options.formData) {
                body = options.formData;
            }
            else if (options.files) {
                body.append('file', options.files);
            }
            else {
                reject('No file selected!');
            }
            if (options.metadata) {
                body.append('metadata', JSON.stringify(options.metadata));
            }
            const headers = { 'Content-Type': 'no-content' };
            const url = this.systemService.getFileIOUrl() + `${options.entityName}`;
            let temp_headers = { headers: this.setHeaders(headers) };
            this.http.post(url, body, temp_headers)
                .subscribe(res => resolve(res), err => reject(err));
        });
    }
    download(options) {
        return new Promise((resolve, reject) => {
            if (options.entityName && (options.metadata || options.fileId)) {
                this.getFileInfo(options).subscribe((res) => {
                    if (options.metadata) {
                        res = res[res.length - 1];
                    }
                    else {
                        res = res.result;
                    }
                    const fileInfo = {
                        contentType: '',
                        filename: ''
                    };
                    if (res && res['contentType'] && res['filename']) {
                        fileInfo['contentType'] = res['contentType'];
                        fileInfo['filename'] = res['filename'];
                        let fileIOURL = this.systemService.getFileIOUrl();
                        if (options.metadata) {
                            fileIOURL += `${options.entityName}?metadataFilter={"metadata.key": "${options.metadata.key}"}`;
                        }
                        else {
                            fileIOURL += `${options.entityName}/${options.fileId}`;
                        }
                        const headers = {
                            'Accept': fileInfo.contentType
                        };
                        this.http.get(fileIOURL, { headers: this.setHeaders(headers), responseType: 'blob' }).subscribe((response) => {
                            const blob = new Blob([response.body], { type: fileInfo.contentType });
                            this.saveFile(blob, fileInfo.filename).then((resp) => {
                            }).catch(err => reject(err));
                        }, err => reject(err));
                    }
                    else {
                        reject('fileInfo not exit');
                    }
                }, err => reject(err));
            }
            else {
                return reject('download options not found');
            }
        });
    }
    saveFile(data, filename) {
        return new Promise((resolve, reject) => {
            if (this.systemService.checkDevice() == 'mobile') {
                const storageLocation = this.systemService.isAndroid() ? cordova.file.externalRootDirectory : cordova.file.documentsDirectory;
                this.createDirectory(storageLocation, this.appProperties.appName, filename, data)
                    .then(res => resolve(res))
                    .catch(err => reject(err));
            }
            else {
                this.saveToBrowser(data, filename).then(res => resolve(res));
            }
        });
    }
    saveToBrowser(data, fileName) {
        return new Promise((resolve) => {
            // Edge 20+
            const isEdge = !( /*@cc_on!@*/false || !!document['documentMode']) && !!window.StyleMedia;
            if (isEdge) {
                window.navigator.msSaveBlob(data, fileName);
            }
            else {
                const downloadURL = window.URL.createObjectURL(data);
                const anchor = document.createElement('a');
                document.body.appendChild(anchor);
                anchor.style.display = 'none';
                anchor.download = fileName;
                anchor.href = downloadURL;
                anchor.click();
                window.URL.revokeObjectURL(downloadURL);
                document.body.removeChild(anchor);
                anchor.remove();
            }
            return resolve('download complete');
        });
    }
    createDirectory(rootDirectory, appName, fileName, data) {
        return new Promise((resolve, reject) => {
            window.resolveLocalFileSystemURL(rootDirectory, (fileSystem) => {
                fileSystem.getDirectory(appName, { create: true }, (dirEntry) => {
                    this.checkFileExist(dirEntry.nativeURL, fileName, 0, (newFileName) => {
                        dirEntry.getFile(newFileName, { create: true }, (targetFile) => {
                            targetFile.createWriter((fileWriter) => {
                                fileWriter.onwriteend = () => {
                                    return resolve(targetFile.toURL());
                                };
                                fileWriter.onerror = (err) => {
                                    return reject(err);
                                };
                                fileWriter.write(data);
                            });
                        });
                    });
                }, err => reject(err));
            }, err => reject(err));
        });
    }
    setHeaders(headerJSON) {
        let headers = new HttpHeaders();
        for (const key in headerJSON) {
            if (key) {
                headers = headers.set(key, headerJSON[key]);
            }
        }
        return headers;
    }
}
NFileIOService.decorators = [
    { type: Injectable }
];
NFileIOService.ctorParameters = () => [
    { type: HttpClient }
];

class NCameraDirective {
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    methodToHandleMouseClickAction() {
        this.getPicture()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    getPicture() {
        return new Promise((resolve, reject) => {
            this.fsv.getPicture(this.cameraOptions).then(res => {
                const options = {
                    'formData': res,
                    'entityName': this.cameraOptions.entityName,
                    'metadata': this.cameraOptions.metadata
                };
                this.fsv.upload(options)
                    .then(uri => resolve(uri))
                    .catch(err => reject(err));
            }).catch(err => reject(err));
        });
    }
}
NCameraDirective.decorators = [
    { type: Directive, args: [{
                selector: '[n-camera]'
            },] }
];
NCameraDirective.ctorParameters = () => [
    { type: NFileIOService }
];
NCameraDirective.propDecorators = {
    cameraOptions: [{ type: Input }],
    onsuccess: [{ type: Output }],
    onerror: [{ type: Output }],
    methodToHandleMouseClickAction: [{ type: HostListener, args: ['click',] }]
};

class NDownloadDirective {
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    methodToHandleMouseClickAction() {
        this.downloadFile()
            .then(res => this.onsuccess.emit(res))
            .catch(err => this.onerror.emit(err));
    }
    downloadFile() {
        return this.fsv.download(this.downloadOptions);
    }
}
NDownloadDirective.decorators = [
    { type: Directive, args: [{ selector: '[n-download]' },] }
];
NDownloadDirective.ctorParameters = () => [
    { type: NFileIOService }
];
NDownloadDirective.propDecorators = {
    downloadOptions: [{ type: Input }],
    onsuccess: [{ type: Output }],
    onerror: [{ type: Output }],
    methodToHandleMouseClickAction: [{ type: HostListener, args: ['click',] }]
};

class NScanDirective {
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    methodToHandleMouseClickAction() {
        this.getPicture()
            .then((sucess) => this.onsuccess.emit(sucess))
            .catch((error) => this.onerror.emit(error));
    }
    getPicture() {
        return new Promise((resolve, reject) => {
            this.fsv.scanPicture(this.scanOptions).then(res => {
                if (this.scanOptions.doUpload) {
                    const options = {
                        'formData': res,
                        'entityName': this.scanOptions.entityName,
                        'metadata': this.scanOptions.metadata
                    };
                    this.fsv.upload(options).then(uri => {
                        resolve(uri);
                    }).catch(err => reject(err));
                }
                else {
                    resolve(res);
                }
            }).catch((err) => {
                return reject(err);
            });
        });
    }
}
NScanDirective.decorators = [
    { type: Directive, args: [{
                selector: '[n-scan]'
            },] }
];
NScanDirective.ctorParameters = () => [
    { type: NFileIOService }
];
NScanDirective.propDecorators = {
    scanOptions: [{ type: Input }],
    onsuccess: [{ type: Output }],
    onerror: [{ type: Output }],
    methodToHandleMouseClickAction: [{ type: HostListener, args: ['click',] }]
};

class NVideoDirective {
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    methodToHandleMouseClickAction() {
        this.getVideo()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    getVideo() {
        return new Promise((resolve, reject) => {
            this.fsv.getVideo(this.videoOptions).then(res => {
                const options = {
                    'formData': res,
                    'entityName': this.videoOptions.entityName,
                    'metadata': this.videoOptions.metadata
                };
                this.fsv.upload(options)
                    .then(uri => resolve(uri))
                    .catch(err => reject(err));
            }).catch(err => reject(err));
        });
    }
}
NVideoDirective.decorators = [
    { type: Directive, args: [{
                selector: '[n-video]'
            },] }
];
NVideoDirective.ctorParameters = () => [
    { type: NFileIOService }
];
NVideoDirective.propDecorators = {
    videoOptions: [{ type: Input }],
    onsuccess: [{ type: Output }],
    onerror: [{ type: Output }],
    methodToHandleMouseClickAction: [{ type: HostListener, args: ['click',] }]
};

class NBarcodeDirective {
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    methodToHandleMouseClickAction() {
        this.getBarcode()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    getBarcode() {
        return new Promise((resolve, reject) => {
            this.fsv.getBarcode(this.barcodeOptions).then(res => {
                return resolve(res);
            }).catch(err => reject(err));
        });
    }
}
NBarcodeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[n-barcode]'
            },] }
];
NBarcodeDirective.ctorParameters = () => [
    { type: NFileIOService }
];
NBarcodeDirective.propDecorators = {
    barcodeOptions: [{ type: Input }],
    onsuccess: [{ type: Output }],
    onerror: [{ type: Output }],
    methodToHandleMouseClickAction: [{ type: HostListener, args: ['click',] }]
};

class NTtsDirective {
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    methodToHandleMouseClickAction() {
        this.getTts()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    getTts() {
        return new Promise((resolve, reject) => {
            this.fsv.getTts(this.ttsOptions).then(res => {
                return resolve(res);
            }).catch(err => reject(err));
        });
    }
}
NTtsDirective.decorators = [
    { type: Directive, args: [{
                selector: '[n-tts]'
            },] }
];
NTtsDirective.ctorParameters = () => [
    { type: NFileIOService }
];
NTtsDirective.propDecorators = {
    ttsOptions: [{ type: Input }],
    onsuccess: [{ type: Output }],
    onerror: [{ type: Output }],
    methodToHandleMouseClickAction: [{ type: HostListener, args: ['click',] }]
};

class NFingerprintDirective {
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    methodToHandleMouseClickAction() {
        this.getFingerprint()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    getFingerprint() {
        return new Promise((resolve, reject) => {
            this.fsv.getFingerprint(this.fingerprintOptions).then(res => {
                return resolve(res);
            }).catch(err => reject(err));
        });
    }
}
NFingerprintDirective.decorators = [
    { type: Directive, args: [{
                selector: '[n-fingerprint]'
            },] }
];
NFingerprintDirective.ctorParameters = () => [
    { type: NFileIOService }
];
NFingerprintDirective.propDecorators = {
    fingerprintOptions: [{ type: Input }],
    onsuccess: [{ type: Output }],
    onerror: [{ type: Output }],
    methodToHandleMouseClickAction: [{ type: HostListener, args: ['click',] }]
};

class NOcrDirective {
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    methodToHandleMouseClickAction() {
        this.getOcr()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    getOcr() {
        return new Promise((resolve, reject) => {
            this.fsv.getOcr(this.ocrOptions).then(res => {
                return resolve(res);
            }).catch(err => reject(err));
        });
    }
}
NOcrDirective.decorators = [
    { type: Directive, args: [{
                selector: '[n-ocr]'
            },] }
];
NOcrDirective.ctorParameters = () => [
    { type: NFileIOService }
];
NOcrDirective.propDecorators = {
    ocrOptions: [{ type: Input }],
    onsuccess: [{ type: Output }],
    onerror: [{ type: Output }],
    methodToHandleMouseClickAction: [{ type: HostListener, args: ['click',] }]
};

class NShakeDirective {
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    methodToHandleMouseClickAction() {
        this.getShake()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    getShake() {
        return new Promise((resolve, reject) => {
            this.fsv.getShake(this.shakeOptions).then(res => {
                return resolve(res);
            }).catch(err => reject(err));
        });
    }
}
NShakeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[n-shake]'
            },] }
];
NShakeDirective.ctorParameters = () => [
    { type: NFileIOService }
];
NShakeDirective.propDecorators = {
    shakeOptions: [{ type: Input }],
    onsuccess: [{ type: Output }],
    onerror: [{ type: Output }],
    methodToHandleMouseClickAction: [{ type: HostListener, args: ['click',] }]
};

class NFileUploadComponent {
    constructor(fileIOService, _renderer) {
        this.fileIOService = fileIOService;
        this._renderer = _renderer;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    /**
     * Method executed when upload button is clicked.
     */
    handleUpload() {
        this.isDone = false;
        if (this.file && this.uploadOptions && this.uploadOptions.entityName && this.uploadOptions.metadata) {
            this.fileIOService.upload({ files: this.file, entityName: this.uploadOptions.entityName, metadata: this.uploadOptions.metadata })
                .then((res) => {
                this.isDone = true;
                this.onsuccess.emit(res);
            })
                .catch(err => this.onerror.emit(err));
        }
        else {
            this.onerror.emit(new Error('Upload options missing'));
        }
    }
    /**
     * Method executed when a file is selected.
     */
    handleSelect(fileInput) {
        if (fileInput.target.files && fileInput.target.files[0]) {
            this.file = fileInput.target.files[0];
            this.fileName = this.file.name;
        }
    }
    /**
     * Methods executed when cancel button is clicked.
     * Clears files.
     */
    cancel() {
        this.file = null;
        this.fileName = null;
        this.isDone = false;
        // check if the file input is rendered before clearing it
        if (this.fileInput) {
            this._renderer.setProperty(this.fileInput, 'value', '');
        }
    }
    disableFileUploadButton() {
        if (typeof this.disableButton === 'boolean') {
            return this.disableButton;
        }
        return this.disableButton === 'disabled' || this.disableButton === 'true' ? true : false;
    }
}
NFileUploadComponent.decorators = [
    { type: Component, args: [{
                selector: 'n-file-upload',
                template: "<div>\n  <button mat-raised-button class=\"bh-file-upload\" (click)=\"fileInput.click()\" color=\"primary\"\n    *ngIf=\"!fileName\" [disabled]=\"disableFileUploadButton()\">\n    <mat-icon>attach_file</mat-icon>\n    <span>Choose a file...</span>\n    <input #fileInput type=\"file\" (change)=\"handleSelect($event)\" style=\"display:none;\" />\n  </button>\n  <div *ngIf=\"fileName\">\n    <button mat-raised-button color=\"primary\" (click)=\"handleUpload()\">\n      <mat-icon>file_upload</mat-icon>\n      <span>{{fileName}}</span>\n    </button>\n    <button *ngIf=\"!isDone\" mat-icon-button color=\"warn\" (click)=\"cancel()\" class=\"bh-file-upload-cancel\">\n      <mat-icon>cancel</mat-icon>\n    </button>\n    <button *ngIf=\"isDone\" mat-icon-button (click)=\"cancel()\" class=\"bh-file-upload-done\">\n      <mat-icon>done</mat-icon>\n    </button>\n  </div>\n</div>\n",
                styles: [".bh-file-upload{padding-left:8px;padding-right:8px}.bh-file-upload-cancel{height:24px;left:-12px;position:relative;top:24px;width:24px}::ng-deep [dir=rtl] .bh-file-upload-cancel{left:0;right:-12px}.bh-file-upload-cancel mat-icon{border-radius:12px;vertical-align:baseline}.bh-file-upload-done{height:24px;left:-13px;position:relative;top:20px;width:24px}::ng-deep [dir=rtl] .bh-file-upload-done{left:0;right:-12px}.bh-file-upload-done mat-icon{border-radius:12px;vertical-align:baseline}"]
            },] }
];
NFileUploadComponent.ctorParameters = () => [
    { type: NFileIOService },
    { type: Renderer2 }
];
NFileUploadComponent.propDecorators = {
    fileInput: [{ type: ViewChild, args: ['fileInput', { static: false },] }],
    uploadOptions: [{ type: Input }],
    disableButton: [{ type: Input, args: ['disabled',] }],
    onsuccess: [{ type: Output }],
    onerror: [{ type: Output }]
};

class NAlertComponent {
    constructor(dialogRef) {
        this.dialogRef = dialogRef;
        this.messageContent = NAlertComponent.message;
        this.titleContent = NAlertComponent.title;
    }
}
NAlertComponent.title = '';
NAlertComponent.message = '';
NAlertComponent.decorators = [
    { type: Component, args: [{
                selector: 'n-alert-dialog',
                template: "\n<div class=\"alertContainer\" fxLayout=\"column\">\n  <h4 mat-dialog-title>{{titleContent}}</h4>\n  <span class=\"msgContainer\" >{{messageContent}}</span>\n  <button mat-raised-button (click)=\"dialogRef.close()\">Close</button>\n</div>\n",
                styles: [".alertContainer{height:auto;width:auto}.msgContainer{margin-bottom:.5em}"]
            },] }
];
NAlertComponent.ctorParameters = () => [
    { type: MatDialogRef }
];

class NAlertService {
    constructor(dialog) {
        this.dialog = dialog;
    }
    alert(message, title, data) {
        NAlertComponent.message = message;
        NAlertComponent.title = title;
        this.dialog.open(NAlertComponent, data);
    }
}
NAlertService.decorators = [
    { type: Injectable }
];
NAlertService.ctorParameters = () => [
    { type: MatDialog }
];

// import { MatSnackBar } from '@angular/material';
class NToggleoptionsComponent {
    constructor() {
        // options = {icon: 'home', value: 'home', disabled: false, 'checked': false}
        this.toggleOptions = [];
        this.align = 'horizontal';
        this.indexChange = new EventEmitter();
        this.valueChange = new EventEmitter();
    }
    // constructor(private snackbar: MatSnackBar) {
    // }
    ngOnInit() {
        if (this.checkNumber(this.checkedIndex)) {
            this.checkedIndex = Number(this.checkedIndex);
        }
        if (this.checkNumber(this.disabledIndex)) {
            this.disabledIndex = Number(this.disabledIndex);
        }
    }
    ngOnChanges(changes) {
        if (changes['checkedIndex'] && this.checkNumber(this.checkedIndex)) {
            this.checkedIndex = Number(this.checkedIndex);
        }
        else if (changes['disabledIndex'] && this.checkNumber(this.disabledIndex)) {
            this.disabledIndex = Number(this.disabledIndex);
        }
    }
    optionClicked(index) {
        if (this.toggleOptions && this.toggleOptions.length > 0) {
            this.indexChange.emit(index);
            if (this.toggleOptions[index] && this.toggleOptions[index].value) {
                this.valueChange.emit(this.toggleOptions[index].value);
            }
            else {
                // this.snackbar.open('Invalid toggle button value', 'OK');
            }
        }
        else {
            // this.snackbar.open('Invalid toggle options', 'OK');
        }
    }
    checkNumber(number) {
        if (number !== undefined && number !== null) {
            return Number.isNaN(Number(number));
        }
        return false;
    }
}
NToggleoptionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'n-toggleoptions',
                template: "<mat-button-toggle-group #group=\"matButtonToggleGroup\" [vertical]=\"align == 'vertical'? true: false\" [value]=\"value\">\n    <mat-button-toggle *ngFor=\"let option of toggleOptions; let i = index;\" [value]=\"option.value\" [disabled]=\"option.disabled || disabledIndex == i\" [checked]=\"option.checked || checkedIndex == i\" (click)=\"optionClicked(i)\" fxLayoutAlign=\"center center\">\n        <mat-icon *ngIf=\"option.icon\">{{option.icon}}</mat-icon>\n        <span *ngIf=\"!option.icon && option.value\">{{option.value}}</span>\n    </mat-button-toggle>\n</mat-button-toggle-group>"
            },] }
];
NToggleoptionsComponent.propDecorators = {
    toggleOptions: [{ type: Input, args: ['toggleOptions',] }],
    align: [{ type: Input, args: ['align',] }],
    disabledIndex: [{ type: Input, args: ['disabledIndex',] }],
    checkedIndex: [{ type: Input, args: ['checkedIndex',] }],
    value: [{ type: Input, args: ['value',] }],
    indexChange: [{ type: Output }],
    valueChange: [{ type: Output }]
};

class NSignatureComponent {
    constructor() {
        this.imageDataValue = '';
        this.signaturePad = '';
        this.mode = 'responsive'; // 'click-fullscreen' or 'responsive'
        this.canvasMode = 'fullscreen'; // 'responsive' or 'fullscreen'
        this.imageDataChange = new EventEmitter();
        this.imageDataUrl = new EventEmitter();
    }
    get imageData() {
        return this.imageDataValue;
    }
    set imageData(val) {
        var _a;
        this.imageDataValue = JSON.parse(JSON.stringify(val));
        if ((_a = this.signaturePad) === null || _a === void 0 ? void 0 : _a.canvas) {
            this.saveFromSavedData(this.imageDataValue);
            if (this.mode !== 'responsive') {
                this.imageSrcDataUrl = this.signaturePad.toDataURL();
            }
        }
    }
    ngOnInit() {
        this.savedDataPoints = this.previousSavedData = JSON.parse(JSON.stringify(this.imageData));
    }
    ngAfterViewInit() {
        this.createCanvas();
        this.saveFromSavedData(this.savedDataPoints);
        setTimeout(() => {
            if (this.mode !== 'responsive') {
                this.hideCanvas();
                this.fitToContainer(this.signaturecanvas.nativeElement, document.body.clientHeight, document.body.clientWidth);
                this.clearCanvas();
                this.drawFromSavedData(this.savedDataPoints);
                this.imageSrcDataUrl = this.signaturePad.toDataURL();
            }
        });
    }
    saveFromSavedData(val) {
        this.updatePreviousSaveData(val);
        this.drawFromSavedData(val);
        this.savedDataPoints = this.signaturePad.toData();
    }
    createCanvas() {
        this.fitToContainer(this.signaturecanvas.nativeElement);
        this.signaturePad = new signing(this.signaturecanvas.nativeElement, this.assignOptions());
    }
    saveCavas() {
        if (this.signaturePad) {
            if (this.signaturePad.isEmpty()) {
                this.clearCanvas();
            }
            this.imageDataChange.emit(JSON.parse(JSON.stringify(this.signaturePad.toData())));
            this.imageDataUrl.emit(this.signaturePad.toDataURL());
            if (this.mode !== 'responsive') {
                this.hideCanvas();
                this.imageSrcDataUrl = this.signaturePad.toDataURL();
            }
            this.saveFromSavedData(this.signaturePad.toData());
        }
    }
    clearCanvas() {
        this.signaturePad.clear();
    }
    undoCanvas() {
        const data = this.signaturePad.toData();
        if (data) {
            data.pop(); // remove the last dot or line
            this.signaturePad.fromData(data);
        }
    }
    showCanvas() {
        this.classAbs = true;
        this.canvasMode = 'fullscreen';
        if (!this.signaturePad) {
            this.createCanvas();
        }
        this.fitToContainer(this.signaturecanvas.nativeElement, document.body.clientHeight, document.body.clientWidth);
        this.clearCanvas();
        this.updatePreviousSaveData(this.savedDataPoints);
        this.drawFromSavedData(this.savedDataPoints);
    }
    hideCanvas() {
        this.canvasMode = 'responsive';
    }
    // cancel currently drawn
    cancel() {
        this.savedDataPoints = Object.assign([], this.previousSavedData);
        this.clearCanvas();
        this.drawFromSavedData(this.savedDataPoints);
    }
    updatePreviousSaveData(val) {
        this.previousSavedData = Object.assign([], val);
    }
    drawFromSavedData(val) {
        if (val) {
            this.signaturePad.clear();
            this.signaturePad.fromData(val);
        }
    }
    fitToContainer(element, height, width) {
        element.style.width = '100%';
        element.style.height = 'calc(100% - 56px)';
        if (height && width) {
            element.width = width;
            element.height = height - 56;
        }
        else {
            element.width = element.offsetWidth;
            element.height = element.offsetHeight;
        }
    }
    assignOptions() {
        let options = {};
        options['backgroundColor'] = this.checkIfValidValueAndRGB(this.backgroundColor, 'backgroundColor');
        options['dotSize'] = this.checkIfValidValueAndNumber(this.dotSize, 'dotSize');
        options['minWidth'] = this.checkIfValidValueAndNumber(this.minWidth, 'minWidth');
        options['maxWidth'] = this.checkIfValidValueAndNumber(this.maxWidth, 'maxWidth');
        options['throttle'] = this.checkIfValidValueAndNumber(this.throttle, 'throttle');
        options['minDistance'] = this.checkIfValidValueAndNumber(this.minDistance, 'minDistance');
        options['penColor'] = this.checkIfValidValueAndRGB(this.penColor, 'penColor');
        options['velocityFilterWeight'] = this.checkIfValidValueAndNumber(this.velocityFilterWeight, 'velocityFilterWeight');
        options = JSON.parse(JSON.stringify(options)); // removing all undefined fields
        options['onBegin'] = this.checkIfValidValueAndFunction(this.onBegin, 'onBegin');
        options['onEnd'] = this.checkIfValidValueAndFunction(this.onEnd, 'onEnd');
        return options;
    }
    checkIfValidValueAndNumber(num, name) {
        if (this.checkIfValid(num) && this.checkNumber(num)) {
            return num;
        }
        this.invalidToast(name, 'num');
        return undefined;
    }
    checkIfValidValueAndRGB(color, name) {
        if (this.checkIfValid(color) && this.checkRGB(color)) {
            return color;
        }
        this.invalidToast(name, 'rgb');
        return undefined;
    }
    checkIfValidValueAndFunction(fn, name) {
        if (this.checkIfValid(fn) && this.checkIfValidFunction(fn)) {
            return fn;
        }
        this.invalidToast(name, 'function format');
        return undefined;
    }
    checkIfValid(value) {
        return value !== undefined && value !== null ? value : undefined;
    }
    checkNumber(num) {
        return !this.checkIsNan(Number(num)) ? Number(num) : undefined;
    }
    checkIfValidFunction(fn) {
        return typeof fn === 'function' ? fn : undefined;
    }
    checkRGB(color) {
        const matchColors1 = new RegExp(/rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/);
        const matchColors2 = new RegExp(/rgb\((\d{1,3}),[ \t]+(\d{1,3}),(\d{1,3})\)/);
        const matchColors3 = new RegExp(/rgb\((\d{1,3}),(\d{1,3}),[ \t]+(\d{1,3})\)/);
        return matchColors1.test(color) || matchColors2.test(color) || matchColors3.test(color);
    }
    checkIsNan(value) {
        return Number.isNaN(value);
    }
    invalidToast(optionName, optionType) {
        switch (optionType) {
            case 'num':
                // this.snackbar.open(`Invalid ${optionName} (number or float) given, taking default value instead.`, 'OK');
                break;
            case 'rgb':
                // this.snackbar.open(`Invalid ${optionName} format Eg: rgb(255, 255, 255)  given, taking default value instead.`, 'OK');
                break;
        }
        return;
    }
    isDataURL(s) {
        if (s && typeof s === 'string') {
            const regex = /^\s*data:([a-z]+\/[a-z]+(;[a-z\-]+\=[a-z\-]+)?)?(;base64)?,[a-z0-9\!\$\&\'\,\(\)\*\+\,\;\=\-\.\_\~\:\@\/\?\%\s]*\s*$/i;
            return !!s.match(regex);
        }
        else {
            return false;
        }
    }
}
NSignatureComponent.decorators = [
    { type: Component, args: [{
                selector: 'n-signature',
                template: "<div style=\"width: 100%; height: 100%\">\n\t<div fxFill fxLayout=\"row\" *ngIf=\"mode === 'click-fullscreen' && canvasMode !== 'fullscreen'\" class=\"signature-component-border\">\n\t\t<div fxFlex=\"calc(100%-56px)\" fxLayout=\"column\">\n\t\t\t<img *ngIf=\"imageSrcDataUrl\" [src]=\"imageSrcDataUrl\" fxFill />\n\t\t</div>\n\t\t<div fxFlex=\"56px\" fxLayoutAlign=\" center\" class=\"signature-component-border\">\n\t\t\t<button mat-icon-button (click)=\"showCanvas()\">\n\t\t\t\t<mat-icon>mode_edit</mat-icon>\n\t\t\t</button>\n\t\t</div>\n\t</div>\n\t<div\n\t\tfxFill\n\t\tfxLayout=\"column\"\n\t\tclass=\"signature-component-border\"\n\t\t[fxShow]=\"(mode === 'click-fullscreen' && canvasMode === 'fullscreen') || mode === 'responsive'\"\n\t\t[ngClass]=\"{'signature-canvas-fullscreen': classAbs}\"\n\t>\n\t\t<canvas #signaturecanvas></canvas>\n\t\t<div fxFlex=\"56px\" fxLayoutAlign=\"center center\" class=\"signature-component-border\">\n\t\t\t<button mat-icon-button (click)=\"undoCanvas()\">\n\t\t\t\t<mat-icon>undo</mat-icon>\n\t\t\t</button>\n\t\t\t<button mat-icon-button (click)=\"clearCanvas()\">\n\t\t\t\t<mat-icon>loop</mat-icon>\n\t\t\t</button>\n\t\t\t<button mat-icon-button (click)=\"saveCavas()\">\n\t\t\t\t<mat-icon>save</mat-icon>\n\t\t\t</button>\n\t\t\t<button mat-icon-button (click)=\"canvasMode = 'responsive'; cancel()\">\n\t\t\t\t<mat-icon>clear</mat-icon>\n\t\t\t</button>\n\t\t</div>\n\t</div>\n</div>\n",
                styles: [`
			:host {
				height: 100% !important;
			}
			.signature-canvas-fullscreen {
				position: absolute;
				top: 0;
				bottom: 0;
				right: 0;
				left: 0;
			}
			.signature-component-border {
				border: 2px solid black;
			}
		`]
            },] }
];
NSignatureComponent.propDecorators = {
    signaturecanvas: [{ type: ViewChild, args: ['signaturecanvas', { static: false },] }],
    canvasparent: [{ type: ViewChild, args: ['canvasparent', { static: false },] }],
    backgroundColor: [{ type: Input, args: ['backgroundColor',] }],
    dotSize: [{ type: Input, args: ['dotSize',] }],
    minWidth: [{ type: Input, args: ['minWidth',] }],
    maxWidth: [{ type: Input, args: ['maxWidth',] }],
    throttle: [{ type: Input, args: ['throttle',] }],
    minDistance: [{ type: Input, args: ['minDistance',] }],
    penColor: [{ type: Input, args: ['penColor',] }],
    velocityFilterWeight: [{ type: Input, args: ['velocityFilterWeight',] }],
    onBegin: [{ type: Input, args: ['onBegin',] }],
    onEnd: [{ type: Input, args: ['onEnd',] }],
    mode: [{ type: Input, args: ['mode',] }],
    imageDataChange: [{ type: Output }],
    imageDataUrl: [{ type: Output }],
    imageData: [{ type: Input }]
};

const EXPORTS = [
    NCameraDirective,
    NDownloadDirective,
    NScanDirective,
    NVideoDirective,
    NBarcodeDirective,
    NTtsDirective,
    NFingerprintDirective,
    NOcrDirective,
    NShakeDirective,
    NFileUploadComponent,
    NAlertComponent,
    NToggleoptionsComponent,
    NSignatureComponent,
];
class NeutrinosModule {
}
NeutrinosModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    HttpClientModule,
                    FormsModule,
                    CommonModule,
                    MatIconModule,
                    MatDialogModule,
                    MatButtonModule,
                    BrowserAnimationsModule,
                    MatButtonToggleModule,
                    NeutrinosSeedServicesModule,
                    FlexLayoutModule,
                ],
                declarations: [
                    EXPORTS,
                ],
                exports: [
                    EXPORTS,
                    NFileUploadComponent,
                    NeutrinosSeedServicesModule,
                ],
                providers: [
                    NFileIOService,
                    NAlertService
                ]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { NAlertComponent, NAlertService, NFileIOService, NFileUploadComponent, NeutrinosModule, NCameraDirective as ɵa, NDownloadDirective as ɵb, NScanDirective as ɵc, NVideoDirective as ɵd, NBarcodeDirective as ɵe, NTtsDirective as ɵf, NFingerprintDirective as ɵg, NOcrDirective as ɵh, NShakeDirective as ɵi, NToggleoptionsComponent as ɵj, NSignatureComponent as ɵk };
//# sourceMappingURL=neutrinos-module.js.map
