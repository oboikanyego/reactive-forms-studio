(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/common/http'), require('@angular/forms'), require('@angular/platform-browser/animations'), require('@angular/flex-layout'), require('neutrinos-seed-services'), require('@angular/material/icon'), require('@angular/material/dialog'), require('@angular/material/button'), require('@angular/material/button-toggle'), require('signature_pad')) :
    typeof define === 'function' && define.amd ? define('neutrinos-module', ['exports', '@angular/core', '@angular/common', '@angular/common/http', '@angular/forms', '@angular/platform-browser/animations', '@angular/flex-layout', 'neutrinos-seed-services', '@angular/material/icon', '@angular/material/dialog', '@angular/material/button', '@angular/material/button-toggle', 'signature_pad'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['neutrinos-module'] = {}, global.ng.core, global.ng.common, global.ng.common.http, global.ng.forms, global.ng.platformBrowser.animations, global.ng.flexLayout, global['neutrinos-seed-services'], global.ng.material.icon, global.ng.material.dialog, global.ng.material.button, global.ng.material.buttonToggle, global.signature_pad));
}(this, (function (exports, core, common, http, forms, animations, flexLayout, neutrinosSeedServices, icon, dialog, button, buttonToggle, signing) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var signing__default = /*#__PURE__*/_interopDefaultLegacy(signing);

    var NFileIOService = /** @class */ (function () {
        function NFileIOService(http) {
            var _this = this;
            this.http = http;
            this.checkFileExist = function (path, fileName, i, callback) {
                return window.resolveLocalFileSystemURL(path + fileName, function () {
                    var length = 4;
                    if (fileName.lastIndexOf('(') > -1) {
                        var isExist = parseInt(fileName.slice((fileName.lastIndexOf('(') + 1), fileName.lastIndexOf(')')), 10);
                        if (!isNaN(isExist)) {
                            i = isExist + 1;
                            if (i > 10 && i < 100) {
                                length += 1;
                            }
                            else if (i > 100) {
                                length += 2;
                            }
                            fileName = fileName.slice(0, (fileName.lastIndexOf('.') - length)) + ' (' + i + ')' + fileName.slice(fileName.lastIndexOf('.'));
                        }
                        else {
                            i += 1;
                            fileName = fileName.slice(0, (fileName.lastIndexOf('.'))) + fileName.slice(fileName.lastIndexOf('.'));
                            fileName = fileName.slice(0, (fileName.lastIndexOf('.'))) + ' (' + i + ')' + fileName.slice(fileName.lastIndexOf('.'));
                        }
                    }
                    else {
                        i += 1;
                        fileName = fileName.slice(0, (fileName.lastIndexOf('.'))) + fileName.slice(fileName.lastIndexOf('.'));
                        fileName = fileName.slice(0, (fileName.lastIndexOf('.'))) + ' (' + i + ')' + fileName.slice(fileName.lastIndexOf('.'));
                    }
                    return _this.checkFileExist(path, fileName, i, callback);
                }, function () {
                    return callback(fileName);
                });
            };
            this.systemService = neutrinosSeedServices.NSystemService.getInstance();
            this.appProperties = this.systemService.getVal('properties');
        }
        NFileIOService.prototype.getFileInfo = function (options) {
            var dataModelURL = this.systemService.getDataModelUrl();
            if (options.metadata) {
                dataModelURL += this.appProperties.appName + "_" + options.entityName + ".files?filter={\"metadata.key\": \"" + options.metadata.key + "\"}";
            }
            else {
                dataModelURL += this.appProperties.appName + "_" + options.entityName + ".files/" + options.fileId;
            }
            return this.http.get(dataModelURL);
        };
        NFileIOService.prototype.getFormData = function (fileUri) {
            return new Promise(function (resolve, reject) {
                window.resolveLocalFileSystemURL(fileUri, function (fileEntry) {
                    fileEntry.file(function (file) {
                        var reader = new FileReader();
                        reader.onerror = function (evt) {
                            return reject(evt);
                        };
                        reader.onloadend = function (evt) {
                            var formData = new FormData();
                            var blob = new Blob([new Uint8Array(reader.result)], { type: file.type });
                            formData.append('file', blob, file.name);
                            return resolve(formData);
                        };
                        reader.readAsArrayBuffer(file);
                    });
                }, function (error) {
                    return reject(error);
                });
            });
        };
        NFileIOService.prototype.getPicture = function (cameraOptions) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                document.addEventListener('deviceready', function () {
                    navigator.camera.getPicture(function (imageUri) {
                        _this.getFormData(imageUri).then(function (res) {
                            return resolve(res);
                        }).catch(function (err) { return reject(err); });
                    }, function (error) {
                        return reject(error);
                    }, cameraOptions);
                }, false);
            });
        };
        NFileIOService.prototype.scanPicture = function (scanOptions) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                document.addEventListener('deviceready', function () {
                    if (scanOptions.hasOwnProperty('sourceType') && scanOptions.hasOwnProperty('doUpload')) {
                        scan.scanDoc(scanOptions.sourceType, function (imageUri) {
                            if (scanOptions.doUpload) {
                                _this.getFormData(imageUri).then(function (res) {
                                    return resolve(res);
                                }).catch(function (err) { return reject(err); });
                            }
                            else {
                                resolve(imageUri);
                            }
                        }, function (error) {
                            return reject(error);
                        });
                    }
                    else {
                        reject('sourceType not found');
                    }
                }, false);
            });
        };
        //Barcode
        NFileIOService.prototype.getBarcode = function (barcodeOptions) {
            return new Promise(function (resolve, reject) {
                document.addEventListener('deviceready', function () {
                    cordova.plugins.barcodeScanner.scan(function (result) {
                        if (result.cancelled) {
                            return reject(result);
                        }
                        else {
                            return resolve(result);
                        }
                    }, function (error) {
                        return reject(error);
                    }, barcodeOptions);
                }, false);
            });
        };
        //Video
        NFileIOService.prototype.getVideo = function (videoOptions) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                document.addEventListener('deviceready', function () {
                    navigator.device.capture.captureVideo(function (mediaFiles) {
                        var imageUri = mediaFiles[0].fullPath;
                        _this.getFormData(imageUri).then(function (res) {
                            return resolve(res);
                        }).catch(function (err) { return reject(err); });
                    }, function (error) {
                        return reject(error);
                    }, {});
                }, false);
            });
        };
        //tts
        NFileIOService.prototype.getTts = function (ttsOptions) {
            return new Promise(function (resolve, reject) {
                document.addEventListener('deviceready', function () {
                    if (ttsOptions.hasOwnProperty('text')) {
                        TTS.speak(ttsOptions).then(function () {
                            return resolve('success');
                        }, function (reason) {
                            return reject(reason);
                        });
                    }
                    else {
                        reject('text not found');
                    }
                }, false);
            });
        };
        //shake
        NFileIOService.prototype.getShake = function (shakeOptions) {
            return new Promise(function (resolve, reject) {
                document.addEventListener('deviceready', function () {
                    if (shakeOptions.hasOwnProperty('start') && shakeOptions.hasOwnProperty('sensitivity')) {
                        if (shakeOptions.start) {
                            shake.startWatch(function () {
                                return resolve('success');
                            }, shakeOptions.sensitivity, function () {
                                return reject('error');
                            });
                        }
                        else {
                            shake.stopWatch();
                        }
                    }
                    else {
                        reject('start or sensitivity not found');
                    }
                }, false);
            });
        };
        //ocr
        NFileIOService.prototype.getOcr = function (ocrOptions) {
            return new Promise(function (resolve, reject) {
                document.addEventListener('deviceready', function () {
                    if (ocrOptions.hasOwnProperty('uriOrBase') && ocrOptions.hasOwnProperty('returnType')) {
                        navigator.camera.getPicture(function (imageData) {
                            textocr.recText(ocrOptions.uriOrBase, ocrOptions.returnType, imageData, function (recognizedText) {
                                return resolve(recognizedText);
                            }, function (message) {
                                return reject(message);
                            });
                        }, function (message) {
                            return reject(message);
                        }, ocrOptions);
                    }
                    else {
                        reject('uriOrBase or returnType not found');
                    }
                }, false);
            });
        };
        //fingerprint
        NFileIOService.prototype.getFingerprint = function (fingerprintOptions) {
            return new Promise(function (resolve, reject) {
                document.addEventListener('deviceready', function () {
                    if (fingerprintOptions.hasOwnProperty('clientId') && fingerprintOptions.hasOwnProperty('clientSecret')) {
                        Fingerprint.isAvailable(function (result) {
                            Fingerprint.show(fingerprintOptions, function () {
                                return resolve('success');
                            }, function (err) {
                                return reject(err);
                            });
                        }, function (message) {
                            return reject(message);
                        });
                    }
                    else {
                        reject('clientId or clientSecret not found');
                    }
                }, false);
            });
        };
        NFileIOService.prototype.upload = function (options) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var body = new FormData();
                if (options.formData) {
                    body = options.formData;
                }
                else if (options.files) {
                    body.append('file', options.files);
                }
                else {
                    reject('No file selected!');
                }
                if (options.metadata) {
                    body.append('metadata', JSON.stringify(options.metadata));
                }
                var headers = { 'Content-Type': 'no-content' };
                var url = _this.systemService.getFileIOUrl() + ("" + options.entityName);
                var temp_headers = { headers: _this.setHeaders(headers) };
                _this.http.post(url, body, temp_headers)
                    .subscribe(function (res) { return resolve(res); }, function (err) { return reject(err); });
            });
        };
        NFileIOService.prototype.download = function (options) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (options.entityName && (options.metadata || options.fileId)) {
                    _this.getFileInfo(options).subscribe(function (res) {
                        if (options.metadata) {
                            res = res[res.length - 1];
                        }
                        else {
                            res = res.result;
                        }
                        var fileInfo = {
                            contentType: '',
                            filename: ''
                        };
                        if (res && res['contentType'] && res['filename']) {
                            fileInfo['contentType'] = res['contentType'];
                            fileInfo['filename'] = res['filename'];
                            var fileIOURL = _this.systemService.getFileIOUrl();
                            if (options.metadata) {
                                fileIOURL += options.entityName + "?metadataFilter={\"metadata.key\": \"" + options.metadata.key + "\"}";
                            }
                            else {
                                fileIOURL += options.entityName + "/" + options.fileId;
                            }
                            var headers = {
                                'Accept': fileInfo.contentType
                            };
                            _this.http.get(fileIOURL, { headers: _this.setHeaders(headers), responseType: 'blob' }).subscribe(function (response) {
                                var blob = new Blob([response.body], { type: fileInfo.contentType });
                                _this.saveFile(blob, fileInfo.filename).then(function (resp) {
                                }).catch(function (err) { return reject(err); });
                            }, function (err) { return reject(err); });
                        }
                        else {
                            reject('fileInfo not exit');
                        }
                    }, function (err) { return reject(err); });
                }
                else {
                    return reject('download options not found');
                }
            });
        };
        NFileIOService.prototype.saveFile = function (data, filename) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (_this.systemService.checkDevice() == 'mobile') {
                    var storageLocation = _this.systemService.isAndroid() ? cordova.file.externalRootDirectory : cordova.file.documentsDirectory;
                    _this.createDirectory(storageLocation, _this.appProperties.appName, filename, data)
                        .then(function (res) { return resolve(res); })
                        .catch(function (err) { return reject(err); });
                }
                else {
                    _this.saveToBrowser(data, filename).then(function (res) { return resolve(res); });
                }
            });
        };
        NFileIOService.prototype.saveToBrowser = function (data, fileName) {
            return new Promise(function (resolve) {
                // Edge 20+
                var isEdge = !( /*@cc_on!@*/false || !!document['documentMode']) && !!window.StyleMedia;
                if (isEdge) {
                    window.navigator.msSaveBlob(data, fileName);
                }
                else {
                    var downloadURL = window.URL.createObjectURL(data);
                    var anchor = document.createElement('a');
                    document.body.appendChild(anchor);
                    anchor.style.display = 'none';
                    anchor.download = fileName;
                    anchor.href = downloadURL;
                    anchor.click();
                    window.URL.revokeObjectURL(downloadURL);
                    document.body.removeChild(anchor);
                    anchor.remove();
                }
                return resolve('download complete');
            });
        };
        NFileIOService.prototype.createDirectory = function (rootDirectory, appName, fileName, data) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                window.resolveLocalFileSystemURL(rootDirectory, function (fileSystem) {
                    fileSystem.getDirectory(appName, { create: true }, function (dirEntry) {
                        _this.checkFileExist(dirEntry.nativeURL, fileName, 0, function (newFileName) {
                            dirEntry.getFile(newFileName, { create: true }, function (targetFile) {
                                targetFile.createWriter(function (fileWriter) {
                                    fileWriter.onwriteend = function () {
                                        return resolve(targetFile.toURL());
                                    };
                                    fileWriter.onerror = function (err) {
                                        return reject(err);
                                    };
                                    fileWriter.write(data);
                                });
                            });
                        });
                    }, function (err) { return reject(err); });
                }, function (err) { return reject(err); });
            });
        };
        NFileIOService.prototype.setHeaders = function (headerJSON) {
            var headers = new http.HttpHeaders();
            for (var key in headerJSON) {
                if (key) {
                    headers = headers.set(key, headerJSON[key]);
                }
            }
            return headers;
        };
        return NFileIOService;
    }());
    NFileIOService.decorators = [
        { type: core.Injectable }
    ];
    NFileIOService.ctorParameters = function () { return [
        { type: http.HttpClient }
    ]; };

    var NCameraDirective = /** @class */ (function () {
        function NCameraDirective(fsv) {
            this.fsv = fsv;
            this.onsuccess = new core.EventEmitter();
            this.onerror = new core.EventEmitter();
        }
        NCameraDirective.prototype.methodToHandleMouseClickAction = function () {
            var _this = this;
            this.getPicture()
                .then(function (sucess) { return _this.onsuccess.emit(sucess); })
                .catch(function (error) { return _this.onerror.emit(error); });
        };
        NCameraDirective.prototype.getPicture = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.fsv.getPicture(_this.cameraOptions).then(function (res) {
                    var options = {
                        'formData': res,
                        'entityName': _this.cameraOptions.entityName,
                        'metadata': _this.cameraOptions.metadata
                    };
                    _this.fsv.upload(options)
                        .then(function (uri) { return resolve(uri); })
                        .catch(function (err) { return reject(err); });
                }).catch(function (err) { return reject(err); });
            });
        };
        return NCameraDirective;
    }());
    NCameraDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[n-camera]'
                },] }
    ];
    NCameraDirective.ctorParameters = function () { return [
        { type: NFileIOService }
    ]; };
    NCameraDirective.propDecorators = {
        cameraOptions: [{ type: core.Input }],
        onsuccess: [{ type: core.Output }],
        onerror: [{ type: core.Output }],
        methodToHandleMouseClickAction: [{ type: core.HostListener, args: ['click',] }]
    };

    var NDownloadDirective = /** @class */ (function () {
        function NDownloadDirective(fsv) {
            this.fsv = fsv;
            this.onsuccess = new core.EventEmitter();
            this.onerror = new core.EventEmitter();
        }
        NDownloadDirective.prototype.methodToHandleMouseClickAction = function () {
            var _this = this;
            this.downloadFile()
                .then(function (res) { return _this.onsuccess.emit(res); })
                .catch(function (err) { return _this.onerror.emit(err); });
        };
        NDownloadDirective.prototype.downloadFile = function () {
            return this.fsv.download(this.downloadOptions);
        };
        return NDownloadDirective;
    }());
    NDownloadDirective.decorators = [
        { type: core.Directive, args: [{ selector: '[n-download]' },] }
    ];
    NDownloadDirective.ctorParameters = function () { return [
        { type: NFileIOService }
    ]; };
    NDownloadDirective.propDecorators = {
        downloadOptions: [{ type: core.Input }],
        onsuccess: [{ type: core.Output }],
        onerror: [{ type: core.Output }],
        methodToHandleMouseClickAction: [{ type: core.HostListener, args: ['click',] }]
    };

    var NScanDirective = /** @class */ (function () {
        function NScanDirective(fsv) {
            this.fsv = fsv;
            this.onsuccess = new core.EventEmitter();
            this.onerror = new core.EventEmitter();
        }
        NScanDirective.prototype.methodToHandleMouseClickAction = function () {
            var _this = this;
            this.getPicture()
                .then(function (sucess) { return _this.onsuccess.emit(sucess); })
                .catch(function (error) { return _this.onerror.emit(error); });
        };
        NScanDirective.prototype.getPicture = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.fsv.scanPicture(_this.scanOptions).then(function (res) {
                    if (_this.scanOptions.doUpload) {
                        var options = {
                            'formData': res,
                            'entityName': _this.scanOptions.entityName,
                            'metadata': _this.scanOptions.metadata
                        };
                        _this.fsv.upload(options).then(function (uri) {
                            resolve(uri);
                        }).catch(function (err) { return reject(err); });
                    }
                    else {
                        resolve(res);
                    }
                }).catch(function (err) {
                    return reject(err);
                });
            });
        };
        return NScanDirective;
    }());
    NScanDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[n-scan]'
                },] }
    ];
    NScanDirective.ctorParameters = function () { return [
        { type: NFileIOService }
    ]; };
    NScanDirective.propDecorators = {
        scanOptions: [{ type: core.Input }],
        onsuccess: [{ type: core.Output }],
        onerror: [{ type: core.Output }],
        methodToHandleMouseClickAction: [{ type: core.HostListener, args: ['click',] }]
    };

    var NVideoDirective = /** @class */ (function () {
        function NVideoDirective(fsv) {
            this.fsv = fsv;
            this.onsuccess = new core.EventEmitter();
            this.onerror = new core.EventEmitter();
        }
        NVideoDirective.prototype.methodToHandleMouseClickAction = function () {
            var _this = this;
            this.getVideo()
                .then(function (sucess) { return _this.onsuccess.emit(sucess); })
                .catch(function (error) { return _this.onerror.emit(error); });
        };
        NVideoDirective.prototype.getVideo = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.fsv.getVideo(_this.videoOptions).then(function (res) {
                    var options = {
                        'formData': res,
                        'entityName': _this.videoOptions.entityName,
                        'metadata': _this.videoOptions.metadata
                    };
                    _this.fsv.upload(options)
                        .then(function (uri) { return resolve(uri); })
                        .catch(function (err) { return reject(err); });
                }).catch(function (err) { return reject(err); });
            });
        };
        return NVideoDirective;
    }());
    NVideoDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[n-video]'
                },] }
    ];
    NVideoDirective.ctorParameters = function () { return [
        { type: NFileIOService }
    ]; };
    NVideoDirective.propDecorators = {
        videoOptions: [{ type: core.Input }],
        onsuccess: [{ type: core.Output }],
        onerror: [{ type: core.Output }],
        methodToHandleMouseClickAction: [{ type: core.HostListener, args: ['click',] }]
    };

    var NBarcodeDirective = /** @class */ (function () {
        function NBarcodeDirective(fsv) {
            this.fsv = fsv;
            this.onsuccess = new core.EventEmitter();
            this.onerror = new core.EventEmitter();
        }
        NBarcodeDirective.prototype.methodToHandleMouseClickAction = function () {
            var _this = this;
            this.getBarcode()
                .then(function (sucess) { return _this.onsuccess.emit(sucess); })
                .catch(function (error) { return _this.onerror.emit(error); });
        };
        NBarcodeDirective.prototype.getBarcode = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.fsv.getBarcode(_this.barcodeOptions).then(function (res) {
                    return resolve(res);
                }).catch(function (err) { return reject(err); });
            });
        };
        return NBarcodeDirective;
    }());
    NBarcodeDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[n-barcode]'
                },] }
    ];
    NBarcodeDirective.ctorParameters = function () { return [
        { type: NFileIOService }
    ]; };
    NBarcodeDirective.propDecorators = {
        barcodeOptions: [{ type: core.Input }],
        onsuccess: [{ type: core.Output }],
        onerror: [{ type: core.Output }],
        methodToHandleMouseClickAction: [{ type: core.HostListener, args: ['click',] }]
    };

    var NTtsDirective = /** @class */ (function () {
        function NTtsDirective(fsv) {
            this.fsv = fsv;
            this.onsuccess = new core.EventEmitter();
            this.onerror = new core.EventEmitter();
        }
        NTtsDirective.prototype.methodToHandleMouseClickAction = function () {
            var _this = this;
            this.getTts()
                .then(function (sucess) { return _this.onsuccess.emit(sucess); })
                .catch(function (error) { return _this.onerror.emit(error); });
        };
        NTtsDirective.prototype.getTts = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.fsv.getTts(_this.ttsOptions).then(function (res) {
                    return resolve(res);
                }).catch(function (err) { return reject(err); });
            });
        };
        return NTtsDirective;
    }());
    NTtsDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[n-tts]'
                },] }
    ];
    NTtsDirective.ctorParameters = function () { return [
        { type: NFileIOService }
    ]; };
    NTtsDirective.propDecorators = {
        ttsOptions: [{ type: core.Input }],
        onsuccess: [{ type: core.Output }],
        onerror: [{ type: core.Output }],
        methodToHandleMouseClickAction: [{ type: core.HostListener, args: ['click',] }]
    };

    var NFingerprintDirective = /** @class */ (function () {
        function NFingerprintDirective(fsv) {
            this.fsv = fsv;
            this.onsuccess = new core.EventEmitter();
            this.onerror = new core.EventEmitter();
        }
        NFingerprintDirective.prototype.methodToHandleMouseClickAction = function () {
            var _this = this;
            this.getFingerprint()
                .then(function (sucess) { return _this.onsuccess.emit(sucess); })
                .catch(function (error) { return _this.onerror.emit(error); });
        };
        NFingerprintDirective.prototype.getFingerprint = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.fsv.getFingerprint(_this.fingerprintOptions).then(function (res) {
                    return resolve(res);
                }).catch(function (err) { return reject(err); });
            });
        };
        return NFingerprintDirective;
    }());
    NFingerprintDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[n-fingerprint]'
                },] }
    ];
    NFingerprintDirective.ctorParameters = function () { return [
        { type: NFileIOService }
    ]; };
    NFingerprintDirective.propDecorators = {
        fingerprintOptions: [{ type: core.Input }],
        onsuccess: [{ type: core.Output }],
        onerror: [{ type: core.Output }],
        methodToHandleMouseClickAction: [{ type: core.HostListener, args: ['click',] }]
    };

    var NOcrDirective = /** @class */ (function () {
        function NOcrDirective(fsv) {
            this.fsv = fsv;
            this.onsuccess = new core.EventEmitter();
            this.onerror = new core.EventEmitter();
        }
        NOcrDirective.prototype.methodToHandleMouseClickAction = function () {
            var _this = this;
            this.getOcr()
                .then(function (sucess) { return _this.onsuccess.emit(sucess); })
                .catch(function (error) { return _this.onerror.emit(error); });
        };
        NOcrDirective.prototype.getOcr = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.fsv.getOcr(_this.ocrOptions).then(function (res) {
                    return resolve(res);
                }).catch(function (err) { return reject(err); });
            });
        };
        return NOcrDirective;
    }());
    NOcrDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[n-ocr]'
                },] }
    ];
    NOcrDirective.ctorParameters = function () { return [
        { type: NFileIOService }
    ]; };
    NOcrDirective.propDecorators = {
        ocrOptions: [{ type: core.Input }],
        onsuccess: [{ type: core.Output }],
        onerror: [{ type: core.Output }],
        methodToHandleMouseClickAction: [{ type: core.HostListener, args: ['click',] }]
    };

    var NShakeDirective = /** @class */ (function () {
        function NShakeDirective(fsv) {
            this.fsv = fsv;
            this.onsuccess = new core.EventEmitter();
            this.onerror = new core.EventEmitter();
        }
        NShakeDirective.prototype.methodToHandleMouseClickAction = function () {
            var _this = this;
            this.getShake()
                .then(function (sucess) { return _this.onsuccess.emit(sucess); })
                .catch(function (error) { return _this.onerror.emit(error); });
        };
        NShakeDirective.prototype.getShake = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.fsv.getShake(_this.shakeOptions).then(function (res) {
                    return resolve(res);
                }).catch(function (err) { return reject(err); });
            });
        };
        return NShakeDirective;
    }());
    NShakeDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[n-shake]'
                },] }
    ];
    NShakeDirective.ctorParameters = function () { return [
        { type: NFileIOService }
    ]; };
    NShakeDirective.propDecorators = {
        shakeOptions: [{ type: core.Input }],
        onsuccess: [{ type: core.Output }],
        onerror: [{ type: core.Output }],
        methodToHandleMouseClickAction: [{ type: core.HostListener, args: ['click',] }]
    };

    var NFileUploadComponent = /** @class */ (function () {
        function NFileUploadComponent(fileIOService, _renderer) {
            this.fileIOService = fileIOService;
            this._renderer = _renderer;
            this.onsuccess = new core.EventEmitter();
            this.onerror = new core.EventEmitter();
        }
        /**
         * Method executed when upload button is clicked.
         */
        NFileUploadComponent.prototype.handleUpload = function () {
            var _this = this;
            this.isDone = false;
            if (this.file && this.uploadOptions && this.uploadOptions.entityName && this.uploadOptions.metadata) {
                this.fileIOService.upload({ files: this.file, entityName: this.uploadOptions.entityName, metadata: this.uploadOptions.metadata })
                    .then(function (res) {
                    _this.isDone = true;
                    _this.onsuccess.emit(res);
                })
                    .catch(function (err) { return _this.onerror.emit(err); });
            }
            else {
                this.onerror.emit(new Error('Upload options missing'));
            }
        };
        /**
         * Method executed when a file is selected.
         */
        NFileUploadComponent.prototype.handleSelect = function (fileInput) {
            if (fileInput.target.files && fileInput.target.files[0]) {
                this.file = fileInput.target.files[0];
                this.fileName = this.file.name;
            }
        };
        /**
         * Methods executed when cancel button is clicked.
         * Clears files.
         */
        NFileUploadComponent.prototype.cancel = function () {
            this.file = null;
            this.fileName = null;
            this.isDone = false;
            // check if the file input is rendered before clearing it
            if (this.fileInput) {
                this._renderer.setProperty(this.fileInput, 'value', '');
            }
        };
        NFileUploadComponent.prototype.disableFileUploadButton = function () {
            if (typeof this.disableButton === 'boolean') {
                return this.disableButton;
            }
            return this.disableButton === 'disabled' || this.disableButton === 'true' ? true : false;
        };
        return NFileUploadComponent;
    }());
    NFileUploadComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'n-file-upload',
                    template: "<div>\n  <button mat-raised-button class=\"bh-file-upload\" (click)=\"fileInput.click()\" color=\"primary\"\n    *ngIf=\"!fileName\" [disabled]=\"disableFileUploadButton()\">\n    <mat-icon>attach_file</mat-icon>\n    <span>Choose a file...</span>\n    <input #fileInput type=\"file\" (change)=\"handleSelect($event)\" style=\"display:none;\" />\n  </button>\n  <div *ngIf=\"fileName\">\n    <button mat-raised-button color=\"primary\" (click)=\"handleUpload()\">\n      <mat-icon>file_upload</mat-icon>\n      <span>{{fileName}}</span>\n    </button>\n    <button *ngIf=\"!isDone\" mat-icon-button color=\"warn\" (click)=\"cancel()\" class=\"bh-file-upload-cancel\">\n      <mat-icon>cancel</mat-icon>\n    </button>\n    <button *ngIf=\"isDone\" mat-icon-button (click)=\"cancel()\" class=\"bh-file-upload-done\">\n      <mat-icon>done</mat-icon>\n    </button>\n  </div>\n</div>\n",
                    styles: [".bh-file-upload{padding-left:8px;padding-right:8px}.bh-file-upload-cancel{height:24px;left:-12px;position:relative;top:24px;width:24px}::ng-deep [dir=rtl] .bh-file-upload-cancel{left:0;right:-12px}.bh-file-upload-cancel mat-icon{border-radius:12px;vertical-align:baseline}.bh-file-upload-done{height:24px;left:-13px;position:relative;top:20px;width:24px}::ng-deep [dir=rtl] .bh-file-upload-done{left:0;right:-12px}.bh-file-upload-done mat-icon{border-radius:12px;vertical-align:baseline}"]
                },] }
    ];
    NFileUploadComponent.ctorParameters = function () { return [
        { type: NFileIOService },
        { type: core.Renderer2 }
    ]; };
    NFileUploadComponent.propDecorators = {
        fileInput: [{ type: core.ViewChild, args: ['fileInput', { static: false },] }],
        uploadOptions: [{ type: core.Input }],
        disableButton: [{ type: core.Input, args: ['disabled',] }],
        onsuccess: [{ type: core.Output }],
        onerror: [{ type: core.Output }]
    };

    var NAlertComponent = /** @class */ (function () {
        function NAlertComponent(dialogRef) {
            this.dialogRef = dialogRef;
            this.messageContent = NAlertComponent.message;
            this.titleContent = NAlertComponent.title;
        }
        return NAlertComponent;
    }());
    NAlertComponent.title = '';
    NAlertComponent.message = '';
    NAlertComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'n-alert-dialog',
                    template: "\n<div class=\"alertContainer\" fxLayout=\"column\">\n  <h4 mat-dialog-title>{{titleContent}}</h4>\n  <span class=\"msgContainer\" >{{messageContent}}</span>\n  <button mat-raised-button (click)=\"dialogRef.close()\">Close</button>\n</div>\n",
                    styles: [".alertContainer{height:auto;width:auto}.msgContainer{margin-bottom:.5em}"]
                },] }
    ];
    NAlertComponent.ctorParameters = function () { return [
        { type: dialog.MatDialogRef }
    ]; };

    var NAlertService = /** @class */ (function () {
        function NAlertService(dialog) {
            this.dialog = dialog;
        }
        NAlertService.prototype.alert = function (message, title, data) {
            NAlertComponent.message = message;
            NAlertComponent.title = title;
            this.dialog.open(NAlertComponent, data);
        };
        return NAlertService;
    }());
    NAlertService.decorators = [
        { type: core.Injectable }
    ];
    NAlertService.ctorParameters = function () { return [
        { type: dialog.MatDialog }
    ]; };

    // import { MatSnackBar } from '@angular/material';
    var NToggleoptionsComponent = /** @class */ (function () {
        function NToggleoptionsComponent() {
            // options = {icon: 'home', value: 'home', disabled: false, 'checked': false}
            this.toggleOptions = [];
            this.align = 'horizontal';
            this.indexChange = new core.EventEmitter();
            this.valueChange = new core.EventEmitter();
        }
        // constructor(private snackbar: MatSnackBar) {
        // }
        NToggleoptionsComponent.prototype.ngOnInit = function () {
            if (this.checkNumber(this.checkedIndex)) {
                this.checkedIndex = Number(this.checkedIndex);
            }
            if (this.checkNumber(this.disabledIndex)) {
                this.disabledIndex = Number(this.disabledIndex);
            }
        };
        NToggleoptionsComponent.prototype.ngOnChanges = function (changes) {
            if (changes['checkedIndex'] && this.checkNumber(this.checkedIndex)) {
                this.checkedIndex = Number(this.checkedIndex);
            }
            else if (changes['disabledIndex'] && this.checkNumber(this.disabledIndex)) {
                this.disabledIndex = Number(this.disabledIndex);
            }
        };
        NToggleoptionsComponent.prototype.optionClicked = function (index) {
            if (this.toggleOptions && this.toggleOptions.length > 0) {
                this.indexChange.emit(index);
                if (this.toggleOptions[index] && this.toggleOptions[index].value) {
                    this.valueChange.emit(this.toggleOptions[index].value);
                }
                else {
                    // this.snackbar.open('Invalid toggle button value', 'OK');
                }
            }
            else {
                // this.snackbar.open('Invalid toggle options', 'OK');
            }
        };
        NToggleoptionsComponent.prototype.checkNumber = function (number) {
            if (number !== undefined && number !== null) {
                return Number.isNaN(Number(number));
            }
            return false;
        };
        return NToggleoptionsComponent;
    }());
    NToggleoptionsComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'n-toggleoptions',
                    template: "<mat-button-toggle-group #group=\"matButtonToggleGroup\" [vertical]=\"align == 'vertical'? true: false\" [value]=\"value\">\n    <mat-button-toggle *ngFor=\"let option of toggleOptions; let i = index;\" [value]=\"option.value\" [disabled]=\"option.disabled || disabledIndex == i\" [checked]=\"option.checked || checkedIndex == i\" (click)=\"optionClicked(i)\" fxLayoutAlign=\"center center\">\n        <mat-icon *ngIf=\"option.icon\">{{option.icon}}</mat-icon>\n        <span *ngIf=\"!option.icon && option.value\">{{option.value}}</span>\n    </mat-button-toggle>\n</mat-button-toggle-group>"
                },] }
    ];
    NToggleoptionsComponent.propDecorators = {
        toggleOptions: [{ type: core.Input, args: ['toggleOptions',] }],
        align: [{ type: core.Input, args: ['align',] }],
        disabledIndex: [{ type: core.Input, args: ['disabledIndex',] }],
        checkedIndex: [{ type: core.Input, args: ['checkedIndex',] }],
        value: [{ type: core.Input, args: ['value',] }],
        indexChange: [{ type: core.Output }],
        valueChange: [{ type: core.Output }]
    };

    var NSignatureComponent = /** @class */ (function () {
        function NSignatureComponent() {
            this.imageDataValue = '';
            this.signaturePad = '';
            this.mode = 'responsive'; // 'click-fullscreen' or 'responsive'
            this.canvasMode = 'fullscreen'; // 'responsive' or 'fullscreen'
            this.imageDataChange = new core.EventEmitter();
            this.imageDataUrl = new core.EventEmitter();
        }
        Object.defineProperty(NSignatureComponent.prototype, "imageData", {
            get: function () {
                return this.imageDataValue;
            },
            set: function (val) {
                var _a;
                this.imageDataValue = JSON.parse(JSON.stringify(val));
                if ((_a = this.signaturePad) === null || _a === void 0 ? void 0 : _a.canvas) {
                    this.saveFromSavedData(this.imageDataValue);
                    if (this.mode !== 'responsive') {
                        this.imageSrcDataUrl = this.signaturePad.toDataURL();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        NSignatureComponent.prototype.ngOnInit = function () {
            this.savedDataPoints = this.previousSavedData = JSON.parse(JSON.stringify(this.imageData));
        };
        NSignatureComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.createCanvas();
            this.saveFromSavedData(this.savedDataPoints);
            setTimeout(function () {
                if (_this.mode !== 'responsive') {
                    _this.hideCanvas();
                    _this.fitToContainer(_this.signaturecanvas.nativeElement, document.body.clientHeight, document.body.clientWidth);
                    _this.clearCanvas();
                    _this.drawFromSavedData(_this.savedDataPoints);
                    _this.imageSrcDataUrl = _this.signaturePad.toDataURL();
                }
            });
        };
        NSignatureComponent.prototype.saveFromSavedData = function (val) {
            this.updatePreviousSaveData(val);
            this.drawFromSavedData(val);
            this.savedDataPoints = this.signaturePad.toData();
        };
        NSignatureComponent.prototype.createCanvas = function () {
            this.fitToContainer(this.signaturecanvas.nativeElement);
            this.signaturePad = new signing__default['default'](this.signaturecanvas.nativeElement, this.assignOptions());
        };
        NSignatureComponent.prototype.saveCavas = function () {
            if (this.signaturePad) {
                if (this.signaturePad.isEmpty()) {
                    this.clearCanvas();
                }
                this.imageDataChange.emit(JSON.parse(JSON.stringify(this.signaturePad.toData())));
                this.imageDataUrl.emit(this.signaturePad.toDataURL());
                if (this.mode !== 'responsive') {
                    this.hideCanvas();
                    this.imageSrcDataUrl = this.signaturePad.toDataURL();
                }
                this.saveFromSavedData(this.signaturePad.toData());
            }
        };
        NSignatureComponent.prototype.clearCanvas = function () {
            this.signaturePad.clear();
        };
        NSignatureComponent.prototype.undoCanvas = function () {
            var data = this.signaturePad.toData();
            if (data) {
                data.pop(); // remove the last dot or line
                this.signaturePad.fromData(data);
            }
        };
        NSignatureComponent.prototype.showCanvas = function () {
            this.classAbs = true;
            this.canvasMode = 'fullscreen';
            if (!this.signaturePad) {
                this.createCanvas();
            }
            this.fitToContainer(this.signaturecanvas.nativeElement, document.body.clientHeight, document.body.clientWidth);
            this.clearCanvas();
            this.updatePreviousSaveData(this.savedDataPoints);
            this.drawFromSavedData(this.savedDataPoints);
        };
        NSignatureComponent.prototype.hideCanvas = function () {
            this.canvasMode = 'responsive';
        };
        // cancel currently drawn
        NSignatureComponent.prototype.cancel = function () {
            this.savedDataPoints = Object.assign([], this.previousSavedData);
            this.clearCanvas();
            this.drawFromSavedData(this.savedDataPoints);
        };
        NSignatureComponent.prototype.updatePreviousSaveData = function (val) {
            this.previousSavedData = Object.assign([], val);
        };
        NSignatureComponent.prototype.drawFromSavedData = function (val) {
            if (val) {
                this.signaturePad.clear();
                this.signaturePad.fromData(val);
            }
        };
        NSignatureComponent.prototype.fitToContainer = function (element, height, width) {
            element.style.width = '100%';
            element.style.height = 'calc(100% - 56px)';
            if (height && width) {
                element.width = width;
                element.height = height - 56;
            }
            else {
                element.width = element.offsetWidth;
                element.height = element.offsetHeight;
            }
        };
        NSignatureComponent.prototype.assignOptions = function () {
            var options = {};
            options['backgroundColor'] = this.checkIfValidValueAndRGB(this.backgroundColor, 'backgroundColor');
            options['dotSize'] = this.checkIfValidValueAndNumber(this.dotSize, 'dotSize');
            options['minWidth'] = this.checkIfValidValueAndNumber(this.minWidth, 'minWidth');
            options['maxWidth'] = this.checkIfValidValueAndNumber(this.maxWidth, 'maxWidth');
            options['throttle'] = this.checkIfValidValueAndNumber(this.throttle, 'throttle');
            options['minDistance'] = this.checkIfValidValueAndNumber(this.minDistance, 'minDistance');
            options['penColor'] = this.checkIfValidValueAndRGB(this.penColor, 'penColor');
            options['velocityFilterWeight'] = this.checkIfValidValueAndNumber(this.velocityFilterWeight, 'velocityFilterWeight');
            options = JSON.parse(JSON.stringify(options)); // removing all undefined fields
            options['onBegin'] = this.checkIfValidValueAndFunction(this.onBegin, 'onBegin');
            options['onEnd'] = this.checkIfValidValueAndFunction(this.onEnd, 'onEnd');
            return options;
        };
        NSignatureComponent.prototype.checkIfValidValueAndNumber = function (num, name) {
            if (this.checkIfValid(num) && this.checkNumber(num)) {
                return num;
            }
            this.invalidToast(name, 'num');
            return undefined;
        };
        NSignatureComponent.prototype.checkIfValidValueAndRGB = function (color, name) {
            if (this.checkIfValid(color) && this.checkRGB(color)) {
                return color;
            }
            this.invalidToast(name, 'rgb');
            return undefined;
        };
        NSignatureComponent.prototype.checkIfValidValueAndFunction = function (fn, name) {
            if (this.checkIfValid(fn) && this.checkIfValidFunction(fn)) {
                return fn;
            }
            this.invalidToast(name, 'function format');
            return undefined;
        };
        NSignatureComponent.prototype.checkIfValid = function (value) {
            return value !== undefined && value !== null ? value : undefined;
        };
        NSignatureComponent.prototype.checkNumber = function (num) {
            return !this.checkIsNan(Number(num)) ? Number(num) : undefined;
        };
        NSignatureComponent.prototype.checkIfValidFunction = function (fn) {
            return typeof fn === 'function' ? fn : undefined;
        };
        NSignatureComponent.prototype.checkRGB = function (color) {
            var matchColors1 = new RegExp(/rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/);
            var matchColors2 = new RegExp(/rgb\((\d{1,3}),[ \t]+(\d{1,3}),(\d{1,3})\)/);
            var matchColors3 = new RegExp(/rgb\((\d{1,3}),(\d{1,3}),[ \t]+(\d{1,3})\)/);
            return matchColors1.test(color) || matchColors2.test(color) || matchColors3.test(color);
        };
        NSignatureComponent.prototype.checkIsNan = function (value) {
            return Number.isNaN(value);
        };
        NSignatureComponent.prototype.invalidToast = function (optionName, optionType) {
            switch (optionType) {
                case 'num':
                    // this.snackbar.open(`Invalid ${optionName} (number or float) given, taking default value instead.`, 'OK');
                    break;
                case 'rgb':
                    // this.snackbar.open(`Invalid ${optionName} format Eg: rgb(255, 255, 255)  given, taking default value instead.`, 'OK');
                    break;
            }
            return;
        };
        NSignatureComponent.prototype.isDataURL = function (s) {
            if (s && typeof s === 'string') {
                var regex = /^\s*data:([a-z]+\/[a-z]+(;[a-z\-]+\=[a-z\-]+)?)?(;base64)?,[a-z0-9\!\$\&\'\,\(\)\*\+\,\;\=\-\.\_\~\:\@\/\?\%\s]*\s*$/i;
                return !!s.match(regex);
            }
            else {
                return false;
            }
        };
        return NSignatureComponent;
    }());
    NSignatureComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'n-signature',
                    template: "<div style=\"width: 100%; height: 100%\">\n\t<div fxFill fxLayout=\"row\" *ngIf=\"mode === 'click-fullscreen' && canvasMode !== 'fullscreen'\" class=\"signature-component-border\">\n\t\t<div fxFlex=\"calc(100%-56px)\" fxLayout=\"column\">\n\t\t\t<img *ngIf=\"imageSrcDataUrl\" [src]=\"imageSrcDataUrl\" fxFill />\n\t\t</div>\n\t\t<div fxFlex=\"56px\" fxLayoutAlign=\" center\" class=\"signature-component-border\">\n\t\t\t<button mat-icon-button (click)=\"showCanvas()\">\n\t\t\t\t<mat-icon>mode_edit</mat-icon>\n\t\t\t</button>\n\t\t</div>\n\t</div>\n\t<div\n\t\tfxFill\n\t\tfxLayout=\"column\"\n\t\tclass=\"signature-component-border\"\n\t\t[fxShow]=\"(mode === 'click-fullscreen' && canvasMode === 'fullscreen') || mode === 'responsive'\"\n\t\t[ngClass]=\"{'signature-canvas-fullscreen': classAbs}\"\n\t>\n\t\t<canvas #signaturecanvas></canvas>\n\t\t<div fxFlex=\"56px\" fxLayoutAlign=\"center center\" class=\"signature-component-border\">\n\t\t\t<button mat-icon-button (click)=\"undoCanvas()\">\n\t\t\t\t<mat-icon>undo</mat-icon>\n\t\t\t</button>\n\t\t\t<button mat-icon-button (click)=\"clearCanvas()\">\n\t\t\t\t<mat-icon>loop</mat-icon>\n\t\t\t</button>\n\t\t\t<button mat-icon-button (click)=\"saveCavas()\">\n\t\t\t\t<mat-icon>save</mat-icon>\n\t\t\t</button>\n\t\t\t<button mat-icon-button (click)=\"canvasMode = 'responsive'; cancel()\">\n\t\t\t\t<mat-icon>clear</mat-icon>\n\t\t\t</button>\n\t\t</div>\n\t</div>\n</div>\n",
                    styles: ["\n\t\t\t:host {\n\t\t\t\theight: 100% !important;\n\t\t\t}\n\t\t\t.signature-canvas-fullscreen {\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: 0;\n\t\t\t\tbottom: 0;\n\t\t\t\tright: 0;\n\t\t\t\tleft: 0;\n\t\t\t}\n\t\t\t.signature-component-border {\n\t\t\t\tborder: 2px solid black;\n\t\t\t}\n\t\t"]
                },] }
    ];
    NSignatureComponent.propDecorators = {
        signaturecanvas: [{ type: core.ViewChild, args: ['signaturecanvas', { static: false },] }],
        canvasparent: [{ type: core.ViewChild, args: ['canvasparent', { static: false },] }],
        backgroundColor: [{ type: core.Input, args: ['backgroundColor',] }],
        dotSize: [{ type: core.Input, args: ['dotSize',] }],
        minWidth: [{ type: core.Input, args: ['minWidth',] }],
        maxWidth: [{ type: core.Input, args: ['maxWidth',] }],
        throttle: [{ type: core.Input, args: ['throttle',] }],
        minDistance: [{ type: core.Input, args: ['minDistance',] }],
        penColor: [{ type: core.Input, args: ['penColor',] }],
        velocityFilterWeight: [{ type: core.Input, args: ['velocityFilterWeight',] }],
        onBegin: [{ type: core.Input, args: ['onBegin',] }],
        onEnd: [{ type: core.Input, args: ['onEnd',] }],
        mode: [{ type: core.Input, args: ['mode',] }],
        imageDataChange: [{ type: core.Output }],
        imageDataUrl: [{ type: core.Output }],
        imageData: [{ type: core.Input }]
    };

    var EXPORTS = [
        NCameraDirective,
        NDownloadDirective,
        NScanDirective,
        NVideoDirective,
        NBarcodeDirective,
        NTtsDirective,
        NFingerprintDirective,
        NOcrDirective,
        NShakeDirective,
        NFileUploadComponent,
        NAlertComponent,
        NToggleoptionsComponent,
        NSignatureComponent,
    ];
    var NeutrinosModule = /** @class */ (function () {
        function NeutrinosModule() {
        }
        return NeutrinosModule;
    }());
    NeutrinosModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        http.HttpClientModule,
                        forms.FormsModule,
                        common.CommonModule,
                        icon.MatIconModule,
                        dialog.MatDialogModule,
                        button.MatButtonModule,
                        animations.BrowserAnimationsModule,
                        buttonToggle.MatButtonToggleModule,
                        neutrinosSeedServices.NeutrinosSeedServicesModule,
                        flexLayout.FlexLayoutModule,
                    ],
                    declarations: [
                        EXPORTS,
                    ],
                    exports: [
                        EXPORTS,
                        NFileUploadComponent,
                        neutrinosSeedServices.NeutrinosSeedServicesModule,
                    ],
                    providers: [
                        NFileIOService,
                        NAlertService
                    ]
                },] }
    ];

    /**
     * Generated bundle index. Do not edit.
     */

    exports.NAlertComponent = NAlertComponent;
    exports.NAlertService = NAlertService;
    exports.NFileIOService = NFileIOService;
    exports.NFileUploadComponent = NFileUploadComponent;
    exports.NeutrinosModule = NeutrinosModule;
    exports.a = NCameraDirective;
    exports.b = NDownloadDirective;
    exports.c = NScanDirective;
    exports.d = NVideoDirective;
    exports.e = NBarcodeDirective;
    exports.f = NTtsDirective;
    exports.g = NFingerprintDirective;
    exports.h = NOcrDirective;
    exports.i = NShakeDirective;
    exports.j = NToggleoptionsComponent;
    exports.k = NSignatureComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=neutrinos-module.umd.js.map
